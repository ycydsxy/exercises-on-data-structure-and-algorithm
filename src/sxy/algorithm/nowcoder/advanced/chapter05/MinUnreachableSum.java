package sxy.algorithm.nowcoder.advanced.chapter05;

/**
 * 最小不可组成和
 * 
 * 给定一个正整数数组arr，求其中的最小不可组成和.最小不可组成和的概念是：在arr中任选数字累加，其累加和中的最小值和最大值可以组成区间[min,max]
 * ， 若其中有某个数不能由上述累加的到 ，则该数为arr的最小不可组成和；若该区间中所有的数都能这样累加得到，则(max+1)为arr的最小不可组成和.
 * 
 * 思路：min就是arr中的最小值，max就是arr的所有数加起来.问题即变为从arr中任选数，问[min,max] 中有哪些数不能被加起来得到，这是典型的背包
 * 问题，用动态规划的思路求解，时间复杂度O(N*(max-min)).
 * 
 * 拓展：如果已知正整数数组arr中有1这个数，能否更快地得到最小不可组成和？
 * 
 * 思路：首先对数组排序，消耗O(Nlog(N))，设现在已知能够得到1~range上的数，目前来到一个新数arr[i]， 如果arr[i]<=range+1，则说明包含
 * 该数后，可以得到1~range+arr[i]上的数；否则range+1就无法得到，故就是最小不可组成和.时间复杂度为O(Nlog(N)+O(N)).
 * 
 * 再拓展：给定一个正整数数组arr和一个正整数N，目标是从arr中任选数，使得能够加出1~N范围内的全部数字。问如果想达到这个目标，arr最少缺哪些数字？
 * 
 * 思路：先想假设没有arr，加出1~N中的全部数字最少缺哪些，答案是1,2,4,8...先按照该方法搞出1~arr[0]-1范围，记录需要哪些数字，包含0位置后
 * 可以搞到1~arr[0]-1+arr[0]范围.设每到一个位置i时，之前能搞到1~range范围，则目前的目标是搞到1~arr[i]-1范围，
 * 如果range>=arr[i]-1则不需要任何数字就能达成目标，且包含当前位置可以搞到1~range+arr[i]范围；否则说明目前的目标没达到，故而需要补充
 * range+1的数字，则当前能够搞到1~range*2+1范围，重复该过程直到当前目标满足。在此过程中range只要超过N就停止，记录的数就是缺的数字.
 * 
 * @author Kevin
 * 
 */
public class MinUnreachableSum {

}
